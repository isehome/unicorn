import { supabase } from '../lib/supabase';

// Generic error handler
const handleError = (error, defaultMessage) => {
  console.error(defaultMessage, error);
  throw new Error(error?.message || defaultMessage);
};

// ============= CONTACTS SERVICE =============
export const contactsService = {
  // Get all contacts with optional filters
  async getAll(filters = {}) {
    try {
      let query = supabase
        .from('contacts')
        .select('*')
        .order('name');

      if (filters.isInternal !== undefined) {
        query = query.eq('is_internal', filters.isInternal);
      }
      if (filters.isActive !== undefined) {
        query = query.eq('is_active', filters.isActive);
      }
      if (filters.search) {
        query = query.or(`name.ilike.%${filters.search}%,email.ilike.%${filters.search}%`);
      }

      const { data, error } = await query;
      if (error) throw error;
      return data || [];
    } catch (error) {
      handleError(error, 'Failed to fetch contacts');
    }
  },

  // Get single contact
  async getById(id) {
    try {
      const { data, error } = await supabase
        .from('contacts')
        .select('*')
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to fetch contact');
    }
  },

  // Create new contact
  async create(contactData) {
    try {
      const { data, error } = await supabase
        .from('contacts')
        .insert([contactData])
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to create contact');
    }
  },

  // Update contact
  async update(id, updates) {
    try {
      const { data, error } = await supabase
        .from('contacts')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to update contact');
    }
  },

  // Delete contact
  async delete(id) {
    try {
      const { error } = await supabase
        .from('contacts')
        .delete()
        .eq('id', id);
      
      if (error) throw error;
      return true;
    } catch (error) {
      handleError(error, 'Failed to delete contact');
    }
  }
};

// ============= PROJECTS SERVICE =============
export const projectsService = {
  // Get all projects
  async getAll() {
    try {
      const { data, error } = await supabase
        .from('projects')
        .select('*')
        .order('created_at', { ascending: false });
      
      if (error) throw error;
      return data || [];
    } catch (error) {
      handleError(error, 'Failed to fetch projects');
    }
  },

  // Get project with stakeholders
  async getWithStakeholders(projectId) {
    try {
      // Get project details
      const { data: project, error: projectError } = await supabase
        .from('projects')
        .select('*')
        .eq('id', projectId)
        .single();
      
      if (projectError) throw projectError;

      // Get stakeholders
      const { data: stakeholders, error: stakeholdersError } = await supabase
        .from('project_stakeholders')
        .select(`
          *,
          contacts!inner (
            id,
            name,
            first_name,
            last_name,
            email,
            phone,
            company,
            is_internal
          ),
          role_types!inner (
            id,
            name,
            category
          )
        `)
        .eq('project_id', projectId)
        .order('contacts(name)');
      
      if (stakeholdersError) throw stakeholdersError;

      return {
        ...project,
        stakeholders: (stakeholders || []).map(s => ({
          id: s.id,
          project_id: s.project_id,
          contact_id: s.contact_id,
          role_type_id: s.role_type_id,
          is_primary: s.is_primary,
          notes: s.notes,
          contact_name: s.contacts.name,
          first_name: s.contacts.first_name,
          last_name: s.contacts.last_name,
          email: s.contacts.email,
          phone: s.contacts.phone,
          company: s.contacts.company,
          is_internal: s.contacts.is_internal,
          role_name: s.role_types.name,
          role_category: s.role_types.category
        }))
      };
    } catch (error) {
      handleError(error, 'Failed to fetch project details');
    }
  },

  // Create project
  async create(projectData) {
    try {
      const { data, error } = await supabase
        .from('projects')
        .insert([projectData])
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to create project');
    }
  },

  // Update project
  async update(id, updates) {
    try {
      const { data, error } = await supabase
        .from('projects')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to update project');
    }
  }
};

// ============= STAKEHOLDERS SERVICE =============
export const stakeholdersService = {
  // Get role types
  async getRoleTypes() {
    try {
      const { data, error } = await supabase
        .from('role_types')
        .select('*')
        .order('display_order');
      
      if (error) throw error;
      return data || [];
    } catch (error) {
      handleError(error, 'Failed to fetch role types');
    }
  },

  // Assign stakeholder to project
  async assignToProject(projectId, contactId, roleTypeId, options = {}) {
    try {
      const { data, error } = await supabase
        .from('project_stakeholders')
        .insert([{
          project_id: projectId,
          contact_id: contactId,
          role_type_id: roleTypeId,
          is_primary: options.isPrimary || false,
          notes: options.notes || null
        }])
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to assign stakeholder');
    }
  },

  // Update stakeholder assignment
  async updateAssignment(assignmentId, updates) {
    try {
      const { data, error } = await supabase
        .from('project_stakeholders')
        .update(updates)
        .eq('id', assignmentId)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to update assignment');
    }
  },

  // Remove stakeholder from project
  async removeFromProject(assignmentId) {
    try {
      const { error } = await supabase
        .from('project_stakeholders')
        .delete()
        .eq('id', assignmentId);
      
      if (error) throw error;
      return true;
    } catch (error) {
      handleError(error, 'Failed to remove stakeholder');
    }
  },

  // Get project stakeholders grouped by category
  async getProjectStakeholdersGrouped(projectId) {
    try {
      const { data, error } = await supabase
        .from('project_stakeholders')
        .select(`
          *,
          contacts!inner (
            id,
            name,
            first_name,
            last_name,
            email,
            phone,
            company,
            is_internal
          ),
          role_types!inner (
            id,
            name,
            category
          )
        `)
        .eq('project_id', projectId)
        .order('contacts(name)');
      
      if (error) throw error;

      // Group by category
      const grouped = {
        internal: [],
        external: []
      };

      (data || []).forEach(stakeholder => {
        const category = stakeholder.contacts.is_internal ? 'internal' : 'external';
        
        // Transform to match expected format
        const transformedStakeholder = {
          id: stakeholder.id,
          project_id: stakeholder.project_id,
          contact_id: stakeholder.contact_id,
          role_type_id: stakeholder.role_type_id,
          is_primary: stakeholder.is_primary,
          notes: stakeholder.notes,
          contact_name: stakeholder.contacts.name,
          first_name: stakeholder.contacts.first_name,
          last_name: stakeholder.contacts.last_name,
          email: stakeholder.contacts.email,
          phone: stakeholder.contacts.phone,
          company: stakeholder.contacts.company,
          is_internal: stakeholder.contacts.is_internal,
          role_name: stakeholder.role_types.name,
          role_category: stakeholder.role_types.category
        };
        
        grouped[category].push(transformedStakeholder);
      });

      return grouped;
    } catch (error) {
      handleError(error, 'Failed to fetch grouped stakeholders');
    }
  }
};

// ============= ISSUES SERVICE =============
export const issuesService = {
  // Get all issues
  async getAll(projectId = null) {
    try {
      let query = supabase
        .from('issues')
        .select('*')
        .order('created_at', { ascending: false });

      if (projectId) {
        query = query.eq('project_id', projectId);
      }

      const { data, error } = await query;
      if (error) throw error;
      return data || [];
    } catch (error) {
      handleError(error, 'Failed to fetch issues');
    }
  },

  // Get issue with details
  async getById(id) {
    try {
      const { data, error } = await supabase
        .from('issues')
        .select(`
          *,
          issue_photos (*)
        `)
        .eq('id', id)
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to fetch issue');
    }
  },

  // Create issue
  async create(issueData) {
    try {
      const { data, error } = await supabase
        .from('issues')
        .insert([issueData])
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to create issue');
    }
  },

  // Update issue
  async update(id, updates) {
    try {
      const { data, error } = await supabase
        .from('issues')
        .update(updates)
        .eq('id', id)
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to update issue');
    }
  },

  // Add photo to issue
  async addPhoto(issueId, photoUrl) {
    try {
      const { data, error } = await supabase
        .from('issue_photos')
        .insert([{
          issue_id: issueId,
          url: photoUrl
        }])
        .select()
        .single();
      
      if (error) throw error;
      return data;
    } catch (error) {
      handleError(error, 'Failed to add photo');
    }
  }
};

// ============= REAL-TIME SUBSCRIPTIONS =============
export const subscriptions = {
  // Subscribe to project changes
  subscribeToProject(projectId, callback) {
    return supabase
      .channel(`project:${projectId}`)
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'project_stakeholders', filter: `project_id=eq.${projectId}` },
        callback
      )
      .subscribe();
  },

  // Subscribe to contacts changes
  subscribeToContacts(callback) {
    return supabase
      .channel('contacts')
      .on('postgres_changes', 
        { event: '*', schema: 'public', table: 'contacts' },
        callback
      )
      .subscribe();
  },

  // Unsubscribe
  unsubscribe(subscription) {
    if (subscription) {
      supabase.removeChannel(subscription);
    }
  }
};
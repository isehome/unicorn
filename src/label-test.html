<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Label Layout Test</title>
    <!-- QRCode Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <style>
        body {
            font-family: system-ui, -apple-system, sans-serif;
            padding: 20px;
            background: #f0f0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            max-width: 900px;
            width: 100%;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 15px;
            align-items: center;
        }

        .nav-controls {
            display: flex;
            gap: 20px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }

        .dimension-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            justify-content: center;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            font-size: 12px;
            font-weight: bold;
            color: #666;
        }

        .card {
            background: white;
            padding: 40px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            min-height: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .label-preview-container {
            position: relative;
            margin: 20px 0;
            display: inline-block;
        }

        .label-preview {
            border: 1px solid #ccc;
            display: block;
            background: white;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        /* Visual guide for non-printable area */
        .guide-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            border: 1px solid rgba(255, 0, 0, 0.3);
        }

        .guide-line {
            position: absolute;
            left: 0;
            width: 100%;
            border-top: 1px dashed rgba(255, 0, 0, 0.5);
        }

        .guide-label {
            position: absolute;
            right: -80px;
            font-size: 10px;
            color: red;
        }

        button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 16px;
        }

        button:hover {
            background: #1d4ed8;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info {
            text-align: left;
            width: 100%;
            max-width: 500px;
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border: 1px solid #ffeeba;
            border-radius: 6px;
            font-size: 14px;
            color: #856404;
        }

        .counter {
            font-weight: bold;
            font-size: 18px;
            color: #4b5563;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Label Layout Test</h1>

        <div class="controls">
            <div class="dimension-controls">
                <div class="control-group">
                    <label for="width">Label Width (in)</label>
                    <input type="number" id="width" value="2.25" step="0.05" style="padding: 5px; width: 80px;">
                </div>
                <div class="control-group">
                    <label for="height">Label Height (in)</label>
                    <input type="number" id="height" value="0.75" step="0.05" style="padding: 5px; width: 80px;">
                </div>
                <div class="control-group">
                    <label for="marginTop">Top Margin (in)</label>
                    <input type="number" id="marginTop" value="0.125" step="0.01" style="padding: 5px; width: 80px;">
                </div>
                <div class="control-group">
                    <label for="marginBottom">Bottom Margin (in)</label>
                    <input type="number" id="marginBottom" value="0.05" step="0.01" style="padding: 5px; width: 80px;">
                </div>
                <button onclick="renderCurrent()">Update Preview</button>
            </div>

            <div class="nav-controls">
                <button onclick="prevLabel()" id="prevBtn">← Previous</button>
                <span class="counter" id="counter">1 / 50</span>
                <button onclick="nextLabel()" id="nextBtn">Next →</button>
            </div>
        </div>

        <div id="output"></div>
    </div>

    <script>
        // --- DATA ---
        const testCases = [
            {
                "uid": "LONG-NAME-TEST",
                "room_name": "Master Bedroom",
                "drop_name": "Master Bedroom North Wall Speaker Left Channel",
                "wire_type": "16/2",
                "drop_type": "Speaker"
            },
            {
                "uid": "PATIOA-S-9557",
                "room_name": "Patio and Outside",
                "drop_name": "Patio and Outside Speaker 9",
                "wire_type": "16/2",
                "drop_type": "Speaker"
            },
            {
                "uid": "LIVING-IP-3284",
                "room_name": "Living Room",
                "drop_name": "IP",
                "wire_type": "Cat 6e",
                "drop_type": "IP/Data"
            },
            {
                "uid": "LIVING-L-8871",
                "room_name": "Living Room",
                "drop_name": "Living Room Lutron 3",
                "wire_type": "Lutron Red",
                "drop_type": "Lutron"
            },
            {
                "uid": "GAMERO-AP-6479",
                "room_name": "Game Room",
                "drop_name": "AP",
                "wire_type": "Cat 6e",
                "drop_type": "Access Point"
            }
        ];

        let currentIndex = 0;

        // --- RENDER LOGIC ---

        const generateWireDropLabelBitmap = async (wireDrop) => {
            // Brady M211 printer resolution: 203 DPI
            const DPI = 203;

            // Inputs
            const widthInput = document.getElementById('width');
            const heightInput = document.getElementById('height');
            const marginTopInput = document.getElementById('marginTop');
            const marginBottomInput = document.getElementById('marginBottom');

            const LABEL_WIDTH_INCHES = parseFloat(widthInput.value);
            const LABEL_HEIGHT_INCHES = parseFloat(heightInput.value);
            const MARGIN_TOP_INCHES = parseFloat(marginTopInput.value);
            const MARGIN_BOTTOM_INCHES = parseFloat(marginBottomInput.value);

            // Convert to pixels
            const WIDTH = Math.floor(LABEL_WIDTH_INCHES * DPI);
            const HEIGHT = Math.floor(LABEL_HEIGHT_INCHES * DPI);
            const MARGIN_TOP = Math.floor(MARGIN_TOP_INCHES * DPI);
            const MARGIN_BOTTOM = Math.floor(MARGIN_BOTTOM_INCHES * DPI);

            // Calculate Safe Printable Area
            const SAFE_HEIGHT = HEIGHT - MARGIN_TOP - MARGIN_BOTTOM;

            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
            const ctx = canvas.getContext('2d');

            // White background
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, WIDTH, HEIGHT);

            // Flag-style layout: QR (45%) | GAP (10%) | TEXT (45%)
            const QR_SECTION_WIDTH = Math.floor(WIDTH * 0.45);
            const GAP_SECTION_WIDTH = Math.floor(WIDTH * 0.10);
            const TEXT_SECTION_WIDTH = WIDTH - QR_SECTION_WIDTH - GAP_SECTION_WIDTH;

            // Draw center line in the gap section
            const centerLineX = QR_SECTION_WIDTH + (GAP_SECTION_WIDTH / 2);
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 3]);
            ctx.beginPath();
            ctx.moveTo(centerLineX, MARGIN_TOP);
            ctx.lineTo(centerLineX, HEIGHT - MARGIN_BOTTOM);
            ctx.stroke();
            ctx.setLineDash([]);

            // LEFT SECTION: QR Code
            // Limit content to 0.75" from center
            const LIMIT_INCHES = 0.75;
            const LIMIT_PX = Math.floor(LIMIT_INCHES * DPI);

            // Maximize size within SAFE_HEIGHT
            const qrSize = Math.floor(SAFE_HEIGHT * 0.95);
            // Align Left Edge to -0.75" from center
            const qrX = centerLineX - LIMIT_PX;
            const qrY = MARGIN_TOP + Math.floor((SAFE_HEIGHT - qrSize) / 2);

            try {
                const qrDataUrl = await QRCode.toDataURL(wireDrop.uid || 'NO-UID', {
                    width: qrSize,
                    margin: 0,
                    errorCorrectionLevel: 'H',
                    color: { dark: '#000000', light: '#FFFFFF' },
                });
                const qrImage = await loadImage(qrDataUrl);
                ctx.drawImage(qrImage, qrX, qrY, qrSize, qrSize);
            } catch (error) {
                console.error('Error generating QR code:', error);
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(qrX, qrY, qrSize, qrSize);
            }

            // RIGHT SECTION: Text Information
            // Move text closer to center line (10px padding)
            const textStartX = centerLineX + 10;
            // Constrain Right Edge to +0.75" from center
            const textEndXLimit = centerLineX + LIMIT_PX;
            const textWidth = textEndXLimit - textStartX;
            const textStartY = MARGIN_TOP;

            ctx.fillStyle = '#000000';
            ctx.textAlign = 'left';

            // 1. Drop Name (Top) - Unchanged
            ctx.font = 'bold 20px Arial';
            const mainText = wireDrop.drop_name || 'No Name';
            const mainLines = wrapText(ctx, mainText, textWidth);
            let currentY = textStartY + 18;

            mainLines.forEach((line, index) => {
                if (index < 3) {
                    ctx.fillText(line, textStartX, currentY);
                    currentY += 22;
                }
            });

            // Bottom Section Calculation (Working Upwards from Bottom)
            let bottomY = HEIGHT - MARGIN_BOTTOM - 4;

            // 3. Drop ID / UID (Now at the very BOTTOM, Smaller, Non-Bold)
            ctx.font = '10px Arial'; // Removed bold, reduced size
            const uidLines = wrapText(ctx, wireDrop.uid || 'NO-UID', textWidth);

            for (let i = uidLines.length - 1; i >= 0; i--) {
                ctx.fillText(uidLines[i], textStartX, bottomY);
                bottomY -= 12; // Smaller line height for smaller font
            }

            // 2. Wire Type / Drop Type (Now ABOVE the UID)
            bottomY -= 4; // Gap between UID and Type
            ctx.font = '16px Arial';
            const wireType = wireDrop.wire_type || 'N/A';
            const dropType = wireDrop.drop_type || 'N/A';
            const typeText = `${wireType} / ${dropType}`;
            const typeLines = wrapText(ctx, typeText, textWidth);

            for (let i = typeLines.length - 1; i >= 0; i--) {
                ctx.fillText(typeLines[i], textStartX, bottomY);
                bottomY -= 18;
            }

            // --- VISUALIZE HARDWARE MARGINS ---
            // The user wants to see where we CANNOT print.
            // We are currently limiting content to +/- 0.75" from center (LIMIT_PX).
            // Everything outside this limit is considered the "Unprintable Margin".

            const leftMarginWidth = centerLineX - LIMIT_PX;
            const rightMarginStart = centerLineX + LIMIT_PX;
            const rightMarginWidth = WIDTH - rightMarginStart;

            ctx.save();
            ctx.fillStyle = 'rgba(255, 0, 0, 0.15)'; // Light red transparent
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 1;

            // Left Unprintable Area
            if (leftMarginWidth > 0) {
                ctx.fillRect(0, 0, leftMarginWidth, HEIGHT);
                ctx.strokeRect(0, 0, leftMarginWidth, HEIGHT);

                // Label
                ctx.save();
                ctx.fillStyle = 'red';
                ctx.font = 'bold 10px Arial';
                ctx.translate(15, HEIGHT / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText("UNPRINTABLE", 0, 0);
                ctx.restore();
            }

            // Right Unprintable Area
            if (rightMarginWidth > 0) {
                ctx.fillRect(rightMarginStart, 0, rightMarginWidth, HEIGHT);
                ctx.strokeRect(rightMarginStart, 0, rightMarginWidth, HEIGHT);

                // Label
                ctx.save();
                ctx.fillStyle = 'red';
                ctx.font = 'bold 10px Arial';
                ctx.translate(WIDTH - 15, HEIGHT / 2);
                ctx.rotate(Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.fillText("UNPRINTABLE", 0, 0);
                ctx.restore();
            }
            ctx.restore();

            // --- GRID & COORDINATES (Origin: Bottom Center) ---

            // Grid Settings
            const GRID_SPACING_INCH = 0.1;
            const GRID_SPACING_PX = GRID_SPACING_INCH * DPI;

            ctx.save();
            ctx.strokeStyle = 'rgba(0, 200, 255, 0.3)'; // Light blue transparent
            ctx.lineWidth = 1;
            ctx.font = '9px Arial';
            ctx.fillStyle = 'rgba(0, 150, 200, 0.8)';

            // Draw Vertical Grid Lines (X-axis)
            // Go Right from Center
            for (let x = centerLineX; x < WIDTH; x += GRID_SPACING_PX) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, HEIGHT);
                ctx.stroke();
                // Label
                const val = ((x - centerLineX) / DPI).toFixed(1);
                if (val !== "0.0") ctx.fillText(val, x + 2, HEIGHT - 2);
            }
            // Go Left from Center
            for (let x = centerLineX; x > 0; x -= GRID_SPACING_PX) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, HEIGHT);
                ctx.stroke();
                // Label
                const val = ((x - centerLineX) / DPI).toFixed(1);
                if (val !== "0.0") ctx.fillText(val, x + 2, HEIGHT - 2);
            }

            // Draw Horizontal Grid Lines (Y-axis)
            // Go Up from Bottom
            for (let y = HEIGHT; y > 0; y -= GRID_SPACING_PX) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(WIDTH, y);
                ctx.stroke();
                // Label
                const val = ((HEIGHT - y) / DPI).toFixed(1);
                if (val !== "0.0") ctx.fillText(val, 2, y - 2);
            }
            ctx.restore();

            // Draw Axes (Stronger Lines)
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.lineWidth = 2;

            // Y-Axis (Center Line) - already drawn as dashed black, let's highlight it
            // X-Axis (Bottom Edge)
            ctx.beginPath();
            ctx.moveTo(0, HEIGHT);
            ctx.lineTo(WIDTH, HEIGHT);
            ctx.stroke();
            ctx.restore();

            // --- MEASUREMENTS (Coordinates) ---

            // QR Coordinates
            const qrLeftX = (qrX - centerLineX) / DPI;
            const qrRightX = ((qrX + qrSize) - centerLineX) / DPI;

            // Text Coordinates
            // Recalculate max width for text
            let maxLineWidth = 0;
            [...mainLines, ...typeLines, ...uidLines].forEach(line => {
                const w = ctx.measureText(line).width;
                if (w > maxLineWidth) maxLineWidth = w;
            });

            const textLeftX = (textStartX - centerLineX) / DPI;
            const textRightX = ((textStartX + maxLineWidth) - centerLineX) / DPI;

            // Draw Measurement Markers
            ctx.save();
            ctx.strokeStyle = 'red';
            ctx.fillStyle = 'red';
            ctx.font = '10px Arial';

            // QR Left Marker
            ctx.beginPath(); ctx.moveTo(qrX, HEIGHT / 2 - 10); ctx.lineTo(qrX, HEIGHT / 2 + 10); ctx.stroke();
            ctx.fillText(qrLeftX.toFixed(3), qrX - 20, HEIGHT / 2);

            // Text Right Marker
            const textEndX = textStartX + maxLineWidth;
            ctx.beginPath(); ctx.moveTo(textEndX, HEIGHT / 2 - 10); ctx.lineTo(textEndX, HEIGHT / 2 + 10); ctx.stroke();
            ctx.fillText(textRightX.toFixed(3), textEndX + 5, HEIGHT / 2);

            ctx.restore();

            return {
                dataUrl: canvas.toDataURL(),
                width: WIDTH,
                height: HEIGHT,
                marginTop: MARGIN_TOP,
                marginBottom: MARGIN_BOTTOM,
                measurements: {
                    qrLeft: qrLeftX.toFixed(3),
                    qrRight: qrRightX.toFixed(3),
                    textLeft: textLeftX.toFixed(3),
                    textRight: textRightX.toFixed(3)
                }
            };
        };

        const loadImage = (dataUrl) => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = dataUrl;
            });
        };

        const wrapText = (ctx, text, maxWidth) => {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';

            words.forEach(word => {
                const testLine = currentLine + (currentLine ? ' ' : '') + word;
                const metrics = ctx.measureText(testLine);

                if (metrics.width > maxWidth && currentLine) {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });

            if (currentLine) {
                lines.push(currentLine);
            }

            return lines;
        };

        // --- UI LOGIC ---

        async function renderCurrent() {
            const output = document.getElementById('output');
            const data = testCases[currentIndex];
            const counter = document.getElementById('counter');
            const prevBtn = document.getElementById('prevBtn');
            const nextBtn = document.getElementById('nextBtn');

            output.innerHTML = '<div class="card">Generating...</div>';

            try {
                const result = await generateWireDropLabelBitmap(data);

                output.innerHTML = `
                    <div class="card">
                        <div class="label-preview-container">
                            <img src="${result.dataUrl}" alt="Label" class="label-preview">
                            <div class="guide-overlay">
                                <div class="guide-line" style="top: ${result.marginTop}px;">
                                    <span class="guide-label" style="top: -15px;">Top Margin</span>
                                </div>
                                <div class="guide-line" style="bottom: ${result.marginBottom}px; border-top: none; border-bottom: 1px dashed rgba(255,0,0,0.5);">
                                    <span class="guide-label" style="bottom: -15px;">Bottom Margin</span>
                                </div>
                            </div>
                        </div>
                        <div class="info">
                            <strong>Coordinates (Origin: Bottom Center):</strong><br>
                            QR Left X: <span style="color:red">${result.measurements.qrLeft}"</span><br>
                            QR Right X: <span style="color:red">${result.measurements.qrRight}"</span><br>
                            Text Left X: <span style="color:blue">${result.measurements.textLeft}"</span><br>
                            Text Right X: <span style="color:blue">${result.measurements.textRight}"</span><br>
                            <br>
                            <strong>Hardware Note:</strong> The Brady M211 has a fixed unprintable margin of ~0.4" on each side (left/right) for continuous labels. This "wasted" space is unavoidable due to the printer's cutter distance. We can only control the content within the label length.
                        </div>
                    </div>
                `;
            } catch (e) {
                output.innerHTML = `<div class="card" style="color:red">Error: ${e.message}</div>`;
                console.error(e);
            }

            counter.textContent = `${currentIndex + 1} / ${testCases.length}`;
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === testCases.length - 1;
        }

        function nextLabel() {
            if (currentIndex < testCases.length - 1) {
                currentIndex++;
                renderCurrent();
            }
        }

        function prevLabel() {
            if (currentIndex > 0) {
                currentIndex--;
                renderCurrent();
            }
        }

        window.onload = renderCurrent;
    </script>
</body>

</html>